{"pageProps":{"frontmatter":{"title":"A new Paella: Simple & Efficient Text-To-Image generation","author":"Dominic Rampas and Pablo Pernias","date":"April 15, 2023","previewImg":"/images/blog/paella.png"},"content":"![](https://user-images.githubusercontent.com/61938694/231021615-38df0a0a-d97e-4f7a-99d9-99952357b4b1.png)\n### Overview.\nWe are releasing a new Paella model which builds on top of our initial paper https://arxiv.org/abs/2211.07292.\nPaella is a text-to-image model that works in a quantized latent space and learns similarly to MUSE and Diffusion models.\nPaella is similar to MUSE as it also works on discrete tokens, but is different in the way tokens are noised as well as\nthe architecture. MUSE uses a transformer, whereas we use a CNN, which comes with many benefits. There are also subtle\ndifferences in the conditioning Paella uses as well how images are sampled. And on the other hand, it can also be seen\nas a discrete diffusion process, which noises images during training and iteratively removes noise during sampling.\nSince the paper-release we worked intensively to bring Paella to a similar level as other \nstate-of-the-art models. With this release we are coming a step closer to that goal. However, our main intention is not\nto make the greatest text-to-image model out there (at least for now), it is to bring text-to-image models closer\nto people outside the field on a technical basis. For example, many models have codebases with many thousand lines of \ncode, that make it pretty hard for people to dive into the code and easily understand it. And that is our proudest\nachievement with Paella. The training and sampling code for Paella is minimalistic and can be understood in \na few minutes, making further extensions, quick tests, idea testing etc. extremely fast. For instance, the entire\nsampling code can be written in just **12 lines** of code.\nIn this blog post we will talk about how Paella works in short, give technical details and release the model.\n\n### How does Paella work?\nPaella works in a quantized latent space, just like StableDiffusion etc., to reduce the computational power needed.\nImages are encoded to a smaller latent space and converted to visual tokens of shape *h x w*. During training,\nthese visual tokens are noised, by replacing a random amount of tokens with other randomly selected tokens\nfrom the codebook of the VQGAN. The noised image are given to the model, along with a timestep and the conditional\ninformation, which is text in our case. The model is tasked to predict the un-noised version of the tokens. \nAnd that's it. The model is optimized with the CrossEntropy loss between the original tokens and the predicted tokens.\nThe amount of noise added during the training is just a linear schedule, meaning that we uniformly sample a percentage \nbetween 0 and 100% and noise that amount of tokens.<br><br>\n\n<figure>\n  <img src=\"https://user-images.githubusercontent.com/61938694/231248435-d21170c1-57b4-4a8f-90a6-62cf3e7effcd.png\" width=\"400\">\n  <figcaption>Images are noised and then fed to the model during training.</figcaption>\n</figure>\n\n\nSampling is also extremely simple, we start with the entire image being random tokens. Then we feed the latent image, \nthe timestep and the condition into the model and let it predict the final image. The models outputs a distribution\nover every token, which we sample from with standard multinomial sampling.  \nSince there are infinite possibilities for the result to look like, just doing a single step results in very basic \nshapes without any details. That is why we add noise to the image again and feed it back to the model. And we repeat\nthat process for a number of times, with less noise being added every time, and slowly get our final image.\nYou can see how images emerge [here](https://user-images.githubusercontent.com/61938694/231252449-d9ac4d15-15ef-4aed-a0de-91fa8746a415.png).<br>\nThe following is the entire sampling code needed to generate images:\n```python\ndef sample(model_inputs, latent_shape, unconditional_inputs, steps=12, renoise_steps=11, temperature=(0.7, 0.3), cfg=8.0):\n    with torch.inference_mode():\n        sampled = torch.randint(low=0, high=model.num_labels, size=latent_shape)\n        initial_noise = sampled.clone()\n        timesteps = torch.linspace(1.0, 0.0, steps+1)\n        temperatures = torch.linspace(temperature[0], temperature[1], steps)\n        for i, t in enumerate(timesteps[:steps]):\n            t = torch.ones(latent_shape[0]) * t\n\n            logits = model(sampled, t, **model_inputs)\n            if cfg:\n                logits = logits * cfg + model(sampled, t, **unconditional_inputs) * (1-cfg)\n            sampled = logits.div(temperatures[i]).softmax(dim=1).permute(0, 2, 3, 1).reshape(-1, logits.size(1))\n            sampled = torch.multinomial(sampled, 1)[:, 0].view(logits.size(0), *logits.shape[2:])\n\n            if i < renoise_steps:\n                t_next = torch.ones(latent_shape[0]) * timesteps[i+1]\n                sampled = model.add_noise(sampled, t_next, random_x=initial_noise)[0]\n    return sampled\n```\n\n### Results\n<img src=\"https://user-images.githubusercontent.com/61938694/231598512-2410c172-5a9d-43f4-947c-6ff7eaee77e7.png\">\nSince Paella is also conditioned on CLIP image embeddings the following things are also possible:<br><br>\n<img src=\"https://user-images.githubusercontent.com/61938694/231278319-16551a8d-bfd1-49c9-b604-c6da3955a6d4.png\">\n<img src=\"https://user-images.githubusercontent.com/61938694/231287637-acd0b9b2-90c7-4518-9b9e-d7edefc6c3af.png\">\n<img src=\"https://user-images.githubusercontent.com/61938694/231287119-42fe496b-e737-4dc5-8e53-613bdba149da.png\">\n\n### Technical Details.\nModel-Architecture: U-Net (Mix of ConvNeXt, DiT etc.) <br>\nDataset: Laion-A, Laion Aesthetic > 6.0 <br>\nTraining Steps: 1.3M <br>\nBatch Size: 2048 <br>\nResolution: 256 <br>\nVQGAN Compression: f4 <br>\nCondition: ByT5-XL (95%), CLIP-H Image Embedding (10%), CLIP-H Text Embedding (10%)\nOptimizer: AdamW\nHardware: 128 A100 @ 80GB <br>\nTraining Time: ~3 weeks <br>\nLearning Rate: 1e-4 <br>\nMore details on the approach, training and sampling can be found in paper and on GitHub.\n\n### Paper, Model, Code Release\nPaper: https://arxiv.org/abs/2211.07292 <br>\nCode: https://github.com/dome272/Paella <br>\nModel: https://huggingface.co/dome272/Paella <br>\n\n\n### Limitations & Conclusion\nThere are still many things to improve for Paella to get on par with standard diffusion models or to even outperform\nthem. One primary thing we notice is that even though we only condition the model on CLIP image embedding 10% of the\ntime, during inference the model heavily relies on the generated image embeddings by a prior model (mapping clip text\nembeddings to image embeddings as proposed in Dalle2). We counteract this by decreasing the importance of the image\nembeddings by reweighing the attention scores. There probably is a way to avoid this happening already in training.\nOther limitations such as lack of composition, text depiction, unawareness of concepts etc. could also be reduced by\ncontinuing the training for longer. As a reference, Paella has only seen as many images as SD 1.4 and due to concerns \nin regard to training collapse (which later turned to be negligible), trained with a 10x lower learning rate for the \nfirst 700k steps. To conclude, this is still work in progress, but our first model that works reasonably well and\na million times better than the first versions we trained months ago.\n\nIt is noteworthy that the design choices for Paella were based on trying to make a simple architecture and \nmodel for text-to-image synthesis, drawing inspiration from existing techniques such as MaskGIT. Furthermore, this \napproach eliminates the need for hyperparameters such as alpha, beta, and alpha_cum_prod, which are typically required \nin diffusion models. As a result, this methodology is particularly well-suited for individuals who are new to the field \nof generative artificial intelligence. Our aim is to lay the groundwork for future research in this domain, fostering\na landscape where AI is accessible and comprehensible to a broader audience. We encourage further exploration of this\napproach, as we are confident in its potential to contribute useful insights and potentially advance the state of the \nart in text-to-image synthesis.\n\n\n### Contributions\n\n**Thanks to:**\n\n* [Romain Beaumont](https://github.com/rom1504/) and [Christoph Schuhmann](https://github.com/christophschuhmann) \nfor constant help on datasets and giving useful advice.\n* [Jenia Jitsev](https://scholar.google.de/citations?user=p1FuAMkAAAAJ&hl=en) for help on writing the blog post and\nuseful discussions.\n* [Richard Vencu](https://github.com/rvencu) for an incredible amount of help regarding hardware issues.\n* [StabilityAI](https://stability.ai/) for providing GPU-Cluster access and faith in Paella.\n\n","slug":"paella"},"__N_SSG":true}